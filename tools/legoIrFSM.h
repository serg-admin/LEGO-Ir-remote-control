/**
 * legoIrFSM.h
 * 
 * Формат IR импульса от пульта lego
 * (Наличие IR считаем 1)
 * (Отсутствие IR считаем 0)
 * Нужно обратить внимание что IR детектор инвертирует сигнал
 *
 * (SH)(SL) HBHBHBHBH BHBHBHBH  BHBHBHBH BHBHBHBH (P)(SH)(SL)...
 * 
 * SH - 1 (150-250 мкС)  - старт передачи
 * SL - 0 (950-1050 мкС) - синхро импульс
 * H  - 1 (150-250 мкС)  - промежуток между импульсами
 * B  - 0 (200-300 мкС, 500-600мкС) бит передаваемых данных. Примем короткий диапазон за 0 а длинный за 1
 * P  - 0 (130-131 мили секунд) Пауза между повторами - мы будем считать паузой все, чт оболее 30 милисекунд
 * 
 * Пульт отправляет 2 байта данных, делает 5 повторений передачи на каждое нажатие.
 * Каждая команда имеет два кода, что позволяет выявлять двойные нажатия.
 *
 *---------------------------------------------------------------------------------------------------
 *
 * Автомат по обработки будет иметь регистры:
 * - Регистр состояния
 * - Счетчик битов
 * - Слово полученное при предыдущем прогоне
 * - Слово полученное при текущем прогоне
 * - Количество пришедших повторов 
 */
 
#ifndef __LEGO_IR_FSM_H_
#define __LEGO_IR_FSM_H_

/**
 * @description Структура команды поступающей с пульта
 */
typedef struct legoIrFSM_cmd {
  uint8_t oddControl : 1; // Бит контроля четности
  uint8_t type : 2;       // Тип контрола (предположительно)
  uint8_t sequence2 : 1;  // Номер нажатия (для двойных нажатий)
  uint8_t direction : 2;  // Направление (для вращающихся контролов)
  uint8_t type2 : 2;      // Тип контрола (инверсно дублирует type)
  uint8_t control : 4;    // Номер котрола (возможно только первые два бита)
  uint8_t chanel  : 3;    // Номер канала 0-3
  uint8_t sequence: 1;    // Дублирует sequence2
} legoIrFSM_cmd;

typedef union legoIrFSN_uCmd {
  uint16_t raw;
  struct legoIrFSM_cmd cmd;
} legoIrFSM_uCmd;

typedef void (*legoIrFSM_received)(legoIrFSM_uCmd value, int8_t rCount);
enum legoIrFSM_states {
  // Пауза
  FSM_ST_P,
  // Старт передачи
  FSM_ST_SHIGH,
  // Синхро импульс
  FSM_ST_SLOW,
  // Промежуток между импульсами
  FSM_ST_H,
  // Значащий бит
  FSM_ST_B
};

legoIrFSM_uCmd legoIrFSM_value;

/**
 * Сброс состояния парсера
 */
void legoIrFSM_reset(void);

/**
 * @describe Импульсы длительностью до 65 000 микросекунд
 *
 * @param len - длительность импульса в микросекундах
 * @param level - уровень импульса (0/1)
 */
void legoIrFSM_upuls(uint16_t len, uint8_t level);

/**
 * @describe Импульсы длительностью до 65 000 милисекунд
 *
 * @param len - длительность импульса в милисекундах
 * @param level - уровень импульса (0/1)
 */
void legoIrFSM_mpuls(uint8_t len, uint8_t level);

/**
 * @description Установить функцию обратного вызова для полученных данных
 *    void fn(int16_t value, int8_t rCount)
 *             value - полученное значение
 *             rCount - количество повторов 
 * 
 * @param fn - функция котороя будет вызываться при получении полного слова данных
 */
void legoIrFSM_setCallBack(legoIrFSM_received fn);
#endif








